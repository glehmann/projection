%
% Complete documentation on the extended LaTeX markup used for Insight
% documentation is available in ``Documenting Insight'', which is part
% of the standard documentation for Insight.  It may be found online
% at:
%
%     http://www.itk.org/

\documentclass{InsightArticle}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  hyperref should be the last package to be loaded.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[dvips,
bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}
% to be able to use options in graphics
\usepackage{graphicx}
% for pseudo code
\usepackage{listings}
% subfigures
\usepackage{subfigure}


%  This is a template for Papers to the Insight Journal. 
%  It is comparable to a technical report format.

% The title should be descriptive enough for people to be able to find
% the relevant document. 
\title{Image projections along an axe}

% Increment the release number whenever significant changes are made.
% The author and/or editor can define 'significant' however they like.
% \release{0.00}

% At minimum, give your name and an email address.  You can include a
% snail-mail address if you like.
\author{Ga\"etan Lehmann}
\authoraddress{Unit\'e de Biologie du D\'eveloppement et de la Reproduction, Institut National de la Recherche Agronomique, 78350 Jouy-en-Josas, France}

\begin{document}
\maketitle

\ifhtml
\chapter*{Front Matter\label{front}}
\fi


\begin{abstract}
\noindent
Image projection is a very common task in image analysis to reduce the dimension
of an image. A base filter is provided with some specialized filters which
implement different projection methods.
\end{abstract}

% \tableofcontents

\section{Introduction}
ITK already provide a class to project an image along an axe:
\doxygen{AccumulateImageFilter}. However, this class is limited to sum
projection and mean projection.


\section{Implementation}

The base class, ProjectionImageFilter, is mainly a copy of
AccumulateImageFilter, with some enhancement:
\begin{itemize}
  \item projection is delegated to a functor
  \item report its progress
\end{itemize}
Different projection types are provided, with specialized classes:
\begin{itemize}
  \item maximum projection (MaximumProjectionImageFilter)
  \item minimum projection (MinimumProjectionImageFilter)
  \item mean projection (MeanProjectionImageFilter)
  \item median projection (MedianProjectionImageFilter)
  \item sum projection (SumProjectionImageFilter)
\end{itemize}
Other projections types can easily be created just by providing a new functor.

AccumulateImageFilter is not modifiable to implement functor support without
breaking the API.

\section{Implemeting a new projection method}
As an example, here is a filter which implement a square sum projection along a
axe. This example may be useful in case of signed input type.

Everything can be done in a single file, itkSquareSumProjectionImageFilter.h.
\small \begin{verbatim}
#ifndef __itkSquareSumProjectionImageFilter_h
#define __itkSquareSumProjectionImageFilter_h
\end{verbatim} \normalsize
The itkProjectionImageFilter.h header must be included.
\small \begin{verbatim}
#include "itkProjectionImageFilter.h"
#include "itkNumericTraits.h"

namespace itk {

namespace Function {
\end{verbatim} \normalsize
Now, create the class which do the real work: receive all the pixel values and
give the result at the end. The class is created in the itk::Function names pace
to avoid putting to much things in itk name space, and is templated over the
type of the input and the output pixel.
On object of this class is created for each pixel in the output image.
\small \begin{verbatim}
template <class TInputPixel, class TOuputPixel>
class SquareSumAccumulator
{
public:
\end{verbatim} \normalsize
The constructor must take one parameter: the number of pixels to accumulate
during the projection. In that case, this parameter is not useful, so it is not
saved in an attribute of the class. The sum is initialized to zero.

The destructor is empty - there is nothing to do.
\small \begin{verbatim}
  SquareSumAccumulator( unsigned long nb )
    {
    m_SquareSum = NumericTraits< TOuputPixel >::Zero;
    }
  ~SquareSumAccumulator(){}
\end{verbatim} \normalsize
The operator() is called for each pixel. In this method, the square sum is
contructed, pixel after pixel. The method is declared inline for best
performance.
\small \begin{verbatim}
  inline TInputPixel operator()( const TInputPixel &input )
    {
    m_SquareSum = m_SquareSum + ( input * input );
    }
\end{verbatim} \normalsize
GetValue() is called to set the value of the result image. In that example, the
sum is just return, but more complex computation can be done here (see the
MedianProjectionImageFilter for an example). ProjectionImageFilter cast the
output of this method to the output image's pixel type.
\small \begin{verbatim}
  inline TOuputPixel GetValue()
    {
    return m_SquareSum;
    }
\end{verbatim} \normalsize
The internal attribute which accumulate the square sum.
\small \begin{verbatim}
  TOuputPixel m_SquareSum;
};
} // end namespace Function
\end{verbatim} \normalsize
The class is declared. It inherits from ProjectionImageFilter, and declares the
usual types and methods.
\small \begin{verbatim}
template <class TInputImage, class TOutputImage>
class ITK_EXPORT SquareSumProjectionImageFilter :
    public
    ProjectionImageFilter<TInputImage, TOutputImage,
      Function::SquareSumAccumulator< typename TInputImage::PixelType,
        typename TOutputImage::PixelType > >
{
public:
  typedef SquareSumProjectionImageFilter Self;
  typedef ProjectionImageFilter<TInputImage, TOutputImage, 
    Function::SquareSumAccumulator< typename TInputImage::PixelType,
      typename TOutputImage::PixelType > > Superclass;

  typedef SmartPointer<Self>   Pointer;
  typedef SmartPointer<const Self>  ConstPointer;

  /** Runtime information support. */
  itkTypeMacro(SquareSumProjectionImageFilter, ProjectionImageFilter);

  /** Method for creation through the object factory. */
  itkNewMacro(Self);


protected:
  SquareSumProjectionImageFilter() {}
  virtual ~SquareSumProjectionImageFilter() {}

private:
  SquareSumProjectionImageFilter(const Self&); //purposely not implemented
  void operator=(const Self&); //purposely not implemented


}; // end SquareSumProjectionImageFilter

} //end namespace itk
#endif
\end{verbatim} \normalsize
That's all.

\section{Performance}

A timing test comparing performance on a $371 \times 371 \times 34$
image showed that the results are similar with AccumulateImageFilter
and the equivalent ProjectionImageFilter, and that the new projection
types have similar performance. The results achieved on an Athlon 64 
Processor 2800+ (1802 MHz) with 512Kb cache, 512 Mb of RAM and gcc
4.0.2 are shown in Table~\ref{perf}.

\begin{table}[htbp]
\centering
\begin{tabular}{cc}
\hline
Filter & execution time \\
\hline
\hline
MaximumProjectionImageFilter & 0.652 s \\
MinimumProjectionImageFilter  & 0.614 s\\
SumProjectionImageFilter  & 0.614 s\\
MeanProjectionImageFilter  & 0.619 s\\
MedianProjectionImageFilter  & 0.831 s\\
AccumulateImageFilter, sum  & 0.615 s\\
AccumulateImageFilter, mean  & 0.617 s\\
\hline
\end{tabular}
\caption{Execution time.\label{perf}}
\end{table}

\section{Examples}
Figure~\ref{maximum0}, Figure~\ref{maximum1}, Figure~\ref{maximum},
Figure~\ref{minimum}, Figure~\ref{mean} and Figure~\ref{median} show the result
of different projection on different axes. The result of
SumProjectionImageFilter in similar to the result of MeanProjectionImageFilter,
but with a higher range of values, and so is not shown here.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{maximum0}
\caption{MaximumProjectionImageFilter, projection along axe x.\label{maximum0}}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{maximum1}
\caption{MaximumProjectionImageFilter, projection along axe y.\label{maximum1}}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{maximum}
\caption{MaximumProjectionImageFilter, projection along axe z.\label{maximum}}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{minimum}
\caption{MinimumProjectionImageFilter, projection along axe z.\label{minimum}}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{mean}
\caption{MeanProjectionImageFilter, projection along axe z.\label{mean}}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{median}
\caption{MedianProjectionImageFilter, projection along axe z\label{median}}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.75]{sigma}
\caption{SigmaProjectionImageFilter, projection along axe z\label{median}}
\end{figure}

\section{Sample code}

\small \begin{verbatim}
#include "itkImageFileReader.h"
#include "itkImageFileWriter.h"
#include "itkCommand.h"
#include "itkSimpleFilterWatcher.h"

#include "itkMaximumProjectionImageFilter.h"
#include "itkExtractImageFilter.h"


int main(int, char * argv[])
{
  int axe = atoi(argv[1]);

  typedef unsigned char PType;
  typedef itk::Image< PType, 3 > IType;
  typedef itk::Image< PType, 2 > IType2;

  typedef itk::ImageFileReader< IType > ReaderType;
  ReaderType::Pointer reader = ReaderType::New();
  reader->SetFileName( argv[2] );

  typedef itk::MaximumProjectionImageFilter< IType, IType > FilterType;
  FilterType::Pointer filter = FilterType::New();
  filter->SetInput( reader->GetOutput() );
  filter->SetAxe( axe );

  itk::SimpleFilterWatcher watcher(filter, "filter");

  filter->Update();

  IType::SizeType inputSize = filter->GetOutput()->GetLargestPossibleRegion().GetSize();

  typedef itk::ExtractImageFilter< IType, IType2 > ExtractType;
  ExtractType::Pointer extract = ExtractType::New();
  extract->SetInput( filter->GetOutput() );

  IType::SizeType size;
  for(int i=0; i<=3; i++) {
    if(i == axe) {
      size[i] = 0;
    } else {
      size[i] = inputSize[i];
     }
  }
  IType::IndexType idx;
  idx.Fill(0);

  IType::RegionType region;
  region.SetSize( size );
  region.SetIndex( idx );
  extract->SetExtractionRegion( region );

  typedef itk::ImageFileWriter< IType2 > WriterType;
  WriterType::Pointer writer = WriterType::New();
  writer->SetInput( extract->GetOutput() );
  writer->SetFileName( argv[3] );
  writer->Update();

  return 0;
}
\end{verbatim} \normalsize

\section{Conclusion}
The new classes give more feature and more flexibility with equivalent
performance than the current available filter, but loss the compatibility with
the previous filter. I propose to mark AccumulateImageFilter as deprecated in
the next release of ITK to incite ITK user to use the new class.


\section{Acknowledgments}
We thank Dr Pierre Adenot and MIMA2 confocal facilities
(\url{http://mima2.jouy.inra.fr})
for providing image samples.


\appendix



\bibliographystyle{plain}
\bibliography{InsightJournal}
\nocite{ITKSoftwareGuide}

\end{document}

